#!/bin/sh

# configent (https://github.com/raas-dev/configent)
# One command automated macOS/Linux laptop/VM/container bootstrapper.
#
# Copyright(C) 2016- Anssi SyrjÃ¤salo (http://a.syrjasalo.com)
# Licensed under GNU Lesser General Public License v3 (LGPL-3.0).

# Proposes git commit message generated with LLM and asks to commit

# shellcheck disable=SC2034  # some colors are unused

### constants ##################################################################

normal=$(tput sgr0)
bold=$(tput bold)
black=$(tput setaf 0)
red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)
blue=$(tput setaf 4)
magenta=$(tput setaf 5)
cyan=$(tput setaf 6)
white=$(tput setaf 7)

### variables ##################################################################

: "${AI_COMMIT_MODEL:="github-copilot/claude-haiku-4.5"}"

################################################################################

if ! command -v opencode >/dev/null; then
  printf "%sError: opencode not found in the system.\n" "$red"
  exit 127
fi

git_diff="$(git diff --staged --no-color)" || {
  printf "%sError: Failed to get git diff.\n" "$red"
  exit 1
}
if [ -z "$git_diff" ]; then
  printf "%sNothing staged to commit.\n" "$red"
  exit 1
fi

# Check for saved commit message from previous failed run
git_dir="$(git rev-parse --git-dir)"
backup_file="$git_dir/AI_COMMIT_BACKUP"

if [ -f "$backup_file" ]; then
  printf "%sFound saved commit message from failed run:%s\n" "$yellow" "$normal"
  printf "\n"
  cat "$backup_file"
  printf "\n"

  if [ -z "$NONINTERACTIVE" ]; then
    printf "%sReuse this message? (y), edit (e), or generate new (n) [Y/e/n] %s> " "${bold}${cyan}" "$normal"
    read -r reuse_choice
    # Default to 'y'
    if [ -z "$reuse_choice" ]; then
      reuse_choice="y"
    fi

    case "$reuse_choice" in
    [yY])
      commit_message="$(cat "$backup_file")"
      choice="y"
      ;;
    [eE])
      commit_message="$(cat "$backup_file")"
      choice="e"
      ;;
    *)
      # Proceed to generate new
      ;;
    esac
  fi
fi

# Store git diff in temporary file to avoid "Argument list too long" error
diff_file=$(mktemp) || {
  printf "%sError: Failed to create temporary file.\n" "$red"
  exit 1
}
cleanup() {
  rm -f "$diff_file"
  if [ -n "$temp_dir" ] && [ -d "$temp_dir" ]; then
    rm -rf "$temp_dir"
  fi
  if [ -n "$original_pwd" ] && [ "$PWD" != "$original_pwd" ]; then
    cd "$original_pwd" || true
  fi
}
trap 'cleanup' EXIT INT TERM
printf '%s' "$git_diff" >"$diff_file"

# Build context message (without git diff)
context_message=""
recent_headlines="$(git log --format="%s" -10 2>/dev/null | head -20)"
if [ -n "$recent_headlines" ]; then
  context_message="RECENT COMMIT MESSAGE HEADLINES FOR REFERENCE:
$recent_headlines"
fi

if [ -n "$*" ]; then
  if [ -n "$context_message" ]; then
    context_message="$context_message

ADDITIONAL CONSTRAINTS FOR TYPE AND SCOPE: $*"
  else
    context_message="ADDITIONAL CONSTRAINTS FOR TYPE AND SCOPE: $*"
  fi
fi

# The commit command reads the git diff from stdin
if [ -z "$commit_message" ]; then
  # Temporarily change to temp directory to prevent opencode from loading .opencode/
  original_pwd="$PWD"
  temp_dir=$(mktemp -d) || {
    printf "%sError: Failed to create temporary directory.\n" "$red"
    exit 1
  }
  cd "$temp_dir" || {
    printf "%sError: Failed to change to temporary directory.\n" "$red"
    exit 1
  }

  if [ -n "$context_message" ]; then
    commit_message="$(printf '%s\n\n%s' "$context_message" "$(cat "$diff_file")" | opencode run \
      --agent coder \
      --model "$AI_COMMIT_MODEL" \
      --command commit)" || {
      printf "%sError: Failed to generate commit message.\n" "$red"
      exit 1
    }
  else
    commit_message="$(cat "$diff_file" | opencode run \
      --agent coder \
      --model "$AI_COMMIT_MODEL" \
      --command commit)" || {
      printf "%sError: Failed to generate commit message.\n" "$red"
      exit 1
    }
  fi

  # Return to original directory (handled by cleanup trap)
  cd "$original_pwd" || {
    printf "%sError: Failed to return to original directory.\n" "$red"
    exit 1
  }
fi

if [ -z "$commit_message" ]; then
  printf "%sError: Generated commit message is empty.\n" "$red"
  exit 1
fi

# Only print if we didn't reuse (reuse block already printed it)
if [ -z "$choice" ]; then
  printf "%s$commit_message" "$white"
  printf "\n"
fi

if [ -z "$NONINTERACTIVE" ] && [ -z "$choice" ]; then
  printf "\n%sCommit with this (y), edit message first (e), or quit (q) [Y/e/q] %s> " "${bold}${cyan}" "$normal"
  # Allow Ctrl+C to work during read
  trap 'printf "\n"; exit 130' INT
  read -r choice || {
    printf "\n"
    exit 130
  }
  trap - INT
  # Default to 'y' if empty
  if [ -z "$choice" ]; then
    choice="y"
  fi
elif [ -n "$NONINTERACTIVE" ]; then
  choice="y"
fi

case "$choice" in
[yY])
  if git commit --message "$commit_message"; then
    rm -f "$backup_file"
  else
    printf "%sError: Failed to commit changes (pre-commit hooks?).\n" "$red"
    printf "%sSaving commit message to %s for reuse...\n" "$yellow" "$backup_file"
    echo "$commit_message" >"$backup_file"
    exit 1
  fi
  ;;
[eE])
  if git commit --edit --message "$commit_message"; then
    rm -f "$backup_file"
  else
    printf "%sError: Failed to commit changes (pre-commit hooks?).\n" "$red"

    # Try to rescue from COMMIT_EDITMSG if it exists
    if [ -f "$git_dir/COMMIT_EDITMSG" ]; then
      cp "$git_dir/COMMIT_EDITMSG" "$backup_file"
      printf "%sSaved edited message to %s for reuse.\n" "$yellow" "$backup_file"
    else
      echo "$commit_message" >"$backup_file"
      printf "%sSaved original message to %s for reuse (edits might be lost).\n" "$yellow" "$backup_file"
    fi
    exit 1
  fi
  ;;
*)
  printf "Aborted.\n"
  exit 1
  ;;
esac
