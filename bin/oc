#!/usr/bin/env bash

# oc: Switch OpenCode configuration profiles

# Save the original directory early
ORIGINAL_DIR="$PWD"

# Cleanup function for temporary directories and state
cleanup_temp_environment() {
  local exit_code=$?

  # Always return to original directory if we changed it
  if [[ "$PWD" != "$ORIGINAL_DIR" ]]; then
    cd "$ORIGINAL_DIR" 2>/dev/null || true
  fi

  # Clean up any temporary directories (only if in a temp location)
  if [[ -n "$TEMP_DIR_TO_CLEAN" && -d "$TEMP_DIR_TO_CLEAN" ]]; then
    case "$TEMP_DIR_TO_CLEAN" in
    /tmp/* | /var/folders/* | "${TMPDIR}"*)
      rm -rf "$TEMP_DIR_TO_CLEAN"
      ;;
    esac
  fi

  return "$exit_code"
}

# Colors (defined early for use in error messages)
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Portable hash function
hash_file() {
  local file="$1"
  if [[ "$OSTYPE" == "darwin"* ]]; then
    md5 -q "$file" 2>/dev/null
  else
    md5sum "$file" 2>/dev/null | awk '{print $1}'
  fi
}

CENTRAL_CONFIG_DIR="$HOME/.config/opencode"
PROFILES_DIR="$CENTRAL_CONFIG_DIR/profiles"
PROJECT_ROOT_DIR="$PWD"
PROJECT_CONFIG_DIR="${PROJECT_CONFIG_DIR:-$PROJECT_ROOT_DIR/.opencode}"

# Validate commands early to show errors before any prompts
# This check must happen before the .opencode prompt
if [[ "$1" == "exec" && $# -lt 3 ]]; then
  echo -e "${YELLOW}Error: exec requires a profile name and a command.${NC}" >&2
  echo -e "${DIM}Usage: oc exec <profile-name> -- command and args${NC}" >&2
  exit 1
fi

# Determine if we should skip the .opencode prompt
# Skip if: in temporary environment (PROFILE_METADATA_FILE set), or exec command
SKIP_OPENCODE_PROMPT=false
if [[ -n "$PROFILE_METADATA_FILE" ]]; then
  SKIP_OPENCODE_PROMPT=true
elif [[ "$1" == "exec" ]]; then
  SKIP_OPENCODE_PROMPT=true
fi

# Skip .opencode directory check if:
# 1. We're in a temporary environment (oc exec) - indicated by PROFILE_METADATA_FILE being set
# 2. We're running 'oc exec' command - it will handle temp directory setup
if [[ "$SKIP_OPENCODE_PROMPT" == "true" || "$1" == "exec" ]]; then
  # Create .opencode directory silently if it doesn't exist
  if [[ ! -d "$PROJECT_CONFIG_DIR" ]] && [[ "$1" != "exec" ]]; then
    mkdir -p "$PROJECT_CONFIG_DIR" 2>/dev/null || true
  fi
fi

PROFILE_METADATA_FILE="$PROJECT_CONFIG_DIR/oc.json"

# Calculate hash of all files in a directory (including nested files)
calculate_profile_hash() {
  local profile_dir="$1"
  local combined_hash=""

  # Sort files recursively and calculate combined hash
  while IFS= read -r file; do
    if [[ -f "$file" ]]; then
      combined_hash+=$(hash_file "$file")
    fi
  done < <(find "$profile_dir" -type f | sort)

  # Return hash of the combined hashes
  if [[ "$OSTYPE" == "darwin"* ]]; then
    echo "$combined_hash" | md5
  else
    echo "$combined_hash" | md5sum | awk '{print $1}'
  fi
}

# Save profile metadata
save_profile_metadata() {
  local profile_name="$1"
  local profile_dir="$2"

  local current_timestamp
  current_timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

  local origin_hash
  origin_hash=$(calculate_profile_hash "$profile_dir")

  cat >"$PROFILE_METADATA_FILE" <<EOF
{
  "name": "$profile_name",
  "source": "$profile_dir",
  "updated_at": "$current_timestamp",
  "origin_hash": "$origin_hash"
}
EOF
}

# Extract JSON value by key (portable)
json_get_value() {
  local file="$1"
  local key="$2"

  if [[ ! -f "$file" ]]; then
    return 1
  fi

  grep -o "\"$key\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" "$file" 2>/dev/null | cut -d'"' -f4
}

# Load profile metadata
load_profile_metadata() {
  if [[ ! -f "$PROFILE_METADATA_FILE" ]]; then
    return 1
  fi

  # Extract profile name from JSON
  local profile_name
  profile_name=$(json_get_value "$PROFILE_METADATA_FILE" "name") || return 1

  if [[ -z "$profile_name" ]]; then
    return 1
  fi

  echo "$profile_name"
}

# Get list of profile directories
get_configs() {
  find -L "$PROFILES_DIR" -maxdepth 1 -mindepth 1 -type d | sort
}

# Calculate hash of project config files (including nested files)
calculate_project_hash() {
  local combined_hash=""

  # Return empty hash if directory doesn't exist
  if [[ ! -d "$PROJECT_CONFIG_DIR" ]]; then
    echo ""
    return
  fi

  # Sort files recursively and calculate combined hash
  while IFS= read -r file; do
    if [[ -f "$file" ]]; then
      combined_hash+=$(hash_file "$file")
    fi
  done < <(find "$PROJECT_CONFIG_DIR" -type f 2>/dev/null | sort)

  # Return hash of the combined hashes
  if [[ "$OSTYPE" == "darwin"* ]]; then
    echo "$combined_hash" | md5
  else
    echo "$combined_hash" | md5sum | awk '{print $1}'
  fi
}

# This function is no longer used, kept for reference
calculate_project_hash_excluding_metadata() {
  local combined_hash=""

  # Return empty hash if directory doesn't exist
  if [[ ! -d "$PROJECT_CONFIG_DIR" ]]; then
    echo ""
    return
  fi

  # Sort files recursively and calculate combined hash, excluding oc.json
  while IFS= read -r file; do
    if [[ -f "$file" ]]; then
      # Skip oc.json
      if [[ "$(basename "$file")" != "oc.json" ]]; then
        combined_hash+=$(hash_file "$file")
      fi
    fi
  done < <(find "$PROJECT_CONFIG_DIR" -type f 2>/dev/null | sort)

  # Return hash of the combined hashes
  if [[ "$OSTYPE" == "darwin"* ]]; then
    echo "$combined_hash" | md5
  else
    echo "$combined_hash" | md5sum | awk '{print $1}'
  fi
}

# Calculate hash of project config files that match the profile structure
# This only hashes files that exist in the profile directory, ignoring other files/subdirs
calculate_project_hash_matching_profile() {
  local profile_dir="$1"
  local combined_hash=""

  # Return empty hash if directory doesn't exist
  if [[ ! -d "$PROJECT_CONFIG_DIR" ]]; then
    echo ""
    return
  fi

  # For each file in the profile, check if corresponding file exists in project
  while IFS= read -r profile_file; do
    if [[ -f "$profile_file" ]]; then
      # Get relative path from profile directory
      local rel_path="${profile_file#"$profile_dir"/}"
      local project_file="$PROJECT_CONFIG_DIR/$rel_path"

      # If corresponding file exists in project, hash it
      if [[ -f "$project_file" ]]; then
        combined_hash+=$(hash_file "$project_file")
      fi
    fi
  done < <(find "$profile_dir" -type f | sort)

  # Return hash of the combined hashes
  if [[ "$OSTYPE" == "darwin"* ]]; then
    echo "$combined_hash" | md5
  else
    echo "$combined_hash" | md5sum | awk '{print $1}'
  fi
}

# Get current active profile by checking metadata file first, then comparing hashes
get_current() {
  # First, check if metadata file exists and is valid
  local metadata_profile=""
  if metadata_profile=$(load_profile_metadata); then
    # If metadata profile directory exists, return it (trust the metadata)
    local metadata_dir="$PROFILES_DIR/$metadata_profile"
    if [[ -d "$metadata_dir" ]]; then
      echo "$metadata_profile"
      return 0
    fi
  fi

  # Calculate project hash once for comparison
  local project_hash
  project_hash=$(calculate_project_hash)

  # If metadata is invalid or missing, find which profile directory matches the current project config
  while IFS= read -r profile_dir; do
    local profile_name
    profile_name=$(basename "$profile_dir")

    # Compare combined hashes instead of individual files
    local profile_hash
    profile_hash=$(calculate_profile_hash "$profile_dir")

    if [[ "$profile_hash" == "$project_hash" ]]; then
      echo "$profile_name"
      return 0
    fi
  done < <(get_configs)

  return 1
}

# Switch to a specific profile with confirmations
switch_to_profile() {
  local profile_name="$1"
  local force_yes="$2"
  local is_init_cmd="$3"

  # Verify profile exists
  local profile_dir="$PROFILES_DIR/$profile_name"
  if [[ ! -d "$profile_dir" ]]; then
    echo -e "${YELLOW}Error: Profile '$profile_name' not found in $PROFILES_DIR${NC}" >&2
    exit 1
  fi

  # Calculate hash of profile directory and project directory to check if anything will change
  # Do this BEFORE any cleanup operations
  local profile_hash
  profile_hash=$(calculate_profile_hash "$profile_dir")

  local project_hash=""
  if [[ -d "$PROJECT_CONFIG_DIR" ]]; then
    project_hash=$(calculate_project_hash_matching_profile "$profile_dir")
  fi

  # Warn if .opencode exists but oc.json doesn't (unmanaged config)
  if [[ -d "$PROJECT_CONFIG_DIR" && ! -f "$PROFILE_METADATA_FILE" ]]; then
    if [[ "$force_yes" != "true" ]]; then
      echo ""
      echo -e "${YELLOW}Warning: .opencode directory exists but is not managed by oc.${NC}"
      echo -e "${YELLOW}Commit your .opencode directory first. Proceeding will overwrite the .opencode directory.${NC}"
      echo -ne "${YELLOW}Continue? [y/N]${NC} "
      read -r confirm_unmanaged
      if [[ ! "$confirm_unmanaged" =~ ^[Yy]$ ]]; then
        echo -e "${DIM}Cancelled.${NC}"
        exit 0
      fi
    fi
    # Clean slate for unmanaged config - delete only .json and .jsonc files, preserve everything else
    find "$PROJECT_ROOT_DIR/.opencode" -maxdepth 1 -type f -name "*.json" ! -name "oc.json" -delete 2>/dev/null || true
    find "$PROJECT_ROOT_DIR/.opencode" -maxdepth 1 -type f -name "*.jsonc" -delete 2>/dev/null || true
  fi

  # Confirm reset if init command is used on oc-managed project (has oc.json)
  if [[ "$is_init_cmd" == "true" && -f "$PROFILE_METADATA_FILE" ]]; then
    if [[ "$force_yes" != "true" ]]; then
      echo ""
      echo -e "${YELLOW}Project already initialized. Re-initializing will overwrite .json and .jsonc files in the .opencode directory.${NC}"
      echo -ne "${YELLOW}Continue? [y/N]${NC} "
      read -r confirm_reset
      if [[ ! "$confirm_reset" =~ ^[Yy]$ ]]; then
        echo -e "${DIM}Cancelled.${NC}"
        exit 0
      fi
    fi
    # Clean slate for re-init - delete only .json and .jsonc files, preserve everything else
    find "$PROJECT_ROOT_DIR/.opencode" -maxdepth 1 -type f -name "*.json" ! -name "oc.json" -delete 2>/dev/null || true
    find "$PROJECT_ROOT_DIR/.opencode" -maxdepth 1 -type f -name "*.jsonc" -delete 2>/dev/null || true
  fi

  echo ""

  local current
  current=$(get_current)

  # Skip "already active" check if this is an init command (user already confirmed reset)
  if [[ "$is_init_cmd" != "true" && "$profile_name" == "$current" ]]; then
    # Check if the origin profile has been updated since it was last copied
    local metadata_file="$PROJECT_CONFIG_DIR/oc.json"
    if [[ -f "$metadata_file" ]]; then
      # Extract stored hash and source path from metadata
      local stored_hash
      stored_hash=$(json_get_value "$metadata_file" "origin_hash")
      local source_path
      source_path=$(json_get_value "$metadata_file" "source")

      # Calculate current hash of the origin profile
      local current_origin_hash
      current_origin_hash=$(calculate_profile_hash "$profile_dir")

      # Only show info if the origin profile hash has changed
      if [[ -n "$stored_hash" && "$stored_hash" != "$current_origin_hash" ]]; then
        local display_path
        display_path="${source_path/#$HOME/~}"
        echo -e "${YELLOW}$profile_name has been updated in the origin ($display_path).${NC}"
        echo -e "${DIM}Run 'oc init $profile_name --yes' to reset from origin (destructive).${NC}"
        exit 0
      else
        local display_path
        display_path="${source_path/#$HOME/~}"
        echo -e "${DIM}$profile_name is already active.${NC}"
        echo -e "${DIM}There are no updates in the origin ($display_path).${NC}"
        exit 0
      fi
    fi
  fi

  # Remove conflicting files from the project config directory before copying
  for profile_file in "$profile_dir"/*; do
    if [[ -f "$profile_file" ]]; then
      local filename
      filename=$(basename "$profile_file")
      local basename_no_ext="${filename%.*}"
      local ext="${filename##*.}"

      # Remove any files with the same basename but different extension
      for existing_file in "$PROJECT_ROOT_DIR/.opencode"/"$basename_no_ext".*; do
        if [[ -f "$existing_file" ]]; then
          local existing_ext="${existing_file##*.}"
          if [[ "$existing_ext" != "$ext" ]]; then
            rm -f "$existing_file"
          fi
        fi
      done
    fi
  done

  # Ensure project config directory exists
  local is_init=false
  if [[ ! -d "$PROJECT_CONFIG_DIR" ]]; then
    is_init=true
    if ! mkdir -p "$PROJECT_CONFIG_DIR" 2>/dev/null; then
      echo -e "${YELLOW}Error: Failed to create $PROJECT_CONFIG_DIR (check permissions)${NC}" >&2
      exit 1
    fi
  fi

  # Copy all files and directories from the selected profile directory to the project config directory
  if cp -r "$profile_dir"/* "$PROJECT_CONFIG_DIR/" 2>/dev/null; then
    # Only save metadata if profile hash differs from project hash (something changed)
    # DEBUG: Uncomment next line to see hashes
    # echo "DEBUG: profile_hash='$profile_hash' project_hash='$project_hash'"
    if [[ "$profile_hash" != "$project_hash" ]]; then
      # Save profile metadata
      save_profile_metadata "$profile_name" "$profile_dir"
    fi

    if [[ "$is_init" == "true" || "$is_init_cmd" == "true" ]]; then
      echo -e "${GREEN}Initialized with: ${BOLD}$profile_name${NC}"
    else
      echo -e "${GREEN}Using: ${BOLD}$profile_name${NC}"
    fi
    echo -e "${DIM}Copied profile files to: $PROJECT_CONFIG_DIR${NC}"
  else
    echo -e "${YELLOW}Error: Failed to copy profile files${NC}"
    exit 1
  fi
}

# Interactive menu with arrow keys
show_menu() {
  local header="${1:-Select OpenCode configuration}"
  local is_init_cmd="${2:-false}"
  local configs=()
  local names=()

  while IFS= read -r file; do
    configs+=("$file")
    names+=("$(basename "$file")")
  done < <(get_configs)

  if [[ ${#configs[@]} -eq 0 ]]; then
    echo -e "${YELLOW}No profile directories found in $PROFILES_DIR${NC}" >&2
    exit 1
  fi

  local current
  current=$(get_current)
  local selected=0
  local total=${#configs[@]}

  # Find and select the currently active configuration by default
  if [[ -n "$current" ]]; then
    for i in "${!names[@]}"; do
      if [[ "${names[$i]}" == "$current" ]]; then
        selected=$i
        break
      fi
    done
  fi

  # Hide cursor
  tput civis

  # Cleanup on exit
  trap 'tput cnorm; echo' EXIT TERM

  echo -e "${BOLD}${header}${NC}"
  echo -e "${DIM}Use arrow keys to navigate, Enter to select, q to quit${NC}"
  echo ""

  local should_redraw=0
  while true; do
    # Move cursor up to redraw menu
    if [[ $should_redraw -eq 1 ]]; then
      tput cuu "$total"
    fi

    # Draw menu
    for i in "${!names[@]}"; do
      local name="${names[$i]}"
      local marker="  "
      local color=""
      local suffix=""

      # Check if this is the currently active config
      if [[ "$name" == "$current" ]]; then
        suffix=" ${GREEN}(active)${NC}"
      fi

      if [[ $i -eq $selected ]]; then
        marker="${YELLOW}>${NC} "
        color="${CYAN}"
        echo -e "${marker}${color}${name}${NC}${suffix}"
      else
        echo -e "  ${DIM}${name}${NC}${suffix}"
      fi
    done

    # Read single keypress
    read -rsn1 key

    # Handle arrow keys (escape sequences)
    if [[ $key == $'\x1b' ]]; then
      read -rsn2 key
      case $key in
      '[A') # Up arrow
        ((selected--))
        [[ $selected -lt 0 ]] && selected=$((total - 1))
        ;;
      '[B') # Down arrow
        ((selected++))
        [[ $selected -ge $total ]] && selected=0
        ;;
      esac
    elif [[ $key == "" ]]; then # Enter
      break
    elif [[ $key == $'\x03' || $key == "q" || $key == "Q" ]]; then # ^C or q
      tput cnorm
      echo ""
      echo -e "${DIM}Cancelled.${NC}"
      exit 0
    elif [[ $key == "j" ]]; then # vim down
      ((selected++))
      [[ $selected -ge $total ]] && selected=0
    elif [[ $key == "k" ]]; then # vim up
      ((selected--))
      [[ $selected -lt 0 ]] && selected=$((total - 1))
    fi

    should_redraw=1
  done

  # Show cursor
  tput cnorm

  # Switch to selected profile
  local selected_name="${names[$selected]}"
  switch_to_profile "$selected_name" "false" "$is_init_cmd"
}

# Show help message
show_help() {
  printf "%b\n" \
    "${CYAN}${BOLD}oc${NC} ${DIM}-${NC} OpenCode configuration manager" \
    "" \
    "${GREEN}USAGE:${NC}" \
    "  ${CYAN}oc${NC} [COMMAND] [OPTIONS]" \
    "" \
    "${GREEN}COMMANDS:${NC}" \
    "  ${DIM}(no command)${NC}" \
    "      Show interactive profile selection menu." \
    "" \
    "  ${CYAN}init${NC} ${DIM}[profile-name] [--yes | -y]${NC}" \
    "      Initialize the project with a profile. Shows an interactive" \
    "      menu if no profile name is given. ${DIM}If the project is already${NC}" \
    "      ${DIM}initialized, confirms to discard existing changes unless${NC}" \
    "      ${DIM}--yes or -y is given.${NC}" \
    "" \
    "      ${DIM}Example:${NC}" \
    "      oc init" \
    "" \
    "  ${CYAN}use${NC} ${DIM}[profile-name]${NC}" \
    "      Select a new profile. Shows an interactive menu if no profile" \
    "      name is given. ${DIM}If there are changes in origin, informs the${NC}" \
    "      ${DIM}user and advises to use 'init' to reset from origin.${NC}" \
    "" \
    "      ${DIM}Example:${NC}" \
    "      oc use omo-zai" \
    "" \
    "  ${CYAN}exec${NC} ${CYAN}<profile-name>${NC} -- ${CYAN}<command>${NC} ${DIM}[args...]${NC}" \
    "      Execute a command in a temporary profile." \
    "      ${DIM}The profile's .opencode directory is copied to a temporary${NC}" \
    "      ${DIM}directory which is deleted after the command is executed.${NC}" \
    "" \
    "      ${DIM}Example:${NC}" \
    "      oc exec computer-use -- pwd" \
    "" \
    "  ${CYAN}help${NC}, ${CYAN}-h${NC}, ${CYAN}--help${NC}" \
    "      Show this help message." \
    "" \
    "${GREEN}EXAMPLES:${NC}" \
    "  oc                                  ${DIM}# Interactive mode${NC}" \
    "  oc init omo-zai                     ${DIM}# Initialize with a profile${NC}" \
    "  oc use omo-antigravity              ${DIM}# Switch to another profile${NC}" \
    "  oc exec computer-use -- pwd         ${DIM}# Run in a temporary profile${NC}" \
    ""
}

# Parse command-line arguments
if [[ $# -gt 0 ]]; then
  case "$1" in
  help | -h | --help)
    show_help
    ;;
  init)
    if [[ $# -lt 2 ]]; then
      show_menu "Select OpenCode configuration to initialize the project with" "true"
    else
      shift
      profile_name="$1"
      shift

      # Check for optional --yes or -y flag
      force_yes="false"
      if [[ "$1" == "--yes" ]] || [[ "$1" == "-y" ]]; then
        force_yes="true"
      fi

      switch_to_profile "$profile_name" "$force_yes" "true"
    fi
    ;;
  exec)
    if [[ $# -lt 3 ]]; then
      echo -e "${YELLOW}Error: exec requires a profile name and a command.${NC}" >&2
      echo -e "${DIM}Usage: oc exec <profile-name> -- command and args${NC}" >&2
      exit 1
    fi
    # Shift past 'exec'
    shift
    exec_profile_name="$1"
    shift

    # Check for '--' separator
    if [[ "$1" != "--" ]]; then
      echo -e "${YELLOW}Error: Expected '--' after profile name.${NC}" >&2
      echo -e "${DIM}Usage: oc exec <profile-name> -- command and args${NC}" >&2
      exit 1
    fi
    shift # Remove '--'

    # Verify profile exists
    exec_profile_dir="$PROFILES_DIR/$exec_profile_name"
    if [[ ! -d "$exec_profile_dir" ]]; then
      echo -e "${YELLOW}Error: Profile '$exec_profile_name' not found in $PROFILES_DIR${NC}" >&2
      exit 1
    fi

    # Create temporary directory
    temp_dir=$(mktemp -d) || {
      echo -e "${YELLOW}Error: Failed to create temporary directory${NC}" >&2
      exit 1
    }

    # Set up cleanup on exit, ensuring we return to original directory
    TEMP_DIR_TO_CLEAN="$temp_dir"
    trap cleanup_temp_environment EXIT TERM

    # Create .opencode directory in temp environment
    temp_opencode_dir="$temp_dir/.opencode"
    mkdir -p "$temp_opencode_dir" || {
      echo -e "${YELLOW}Error: Failed to create .opencode directory in temp environment${NC}" >&2
      exit 1
    }

    # Copy profile files to temporary .opencode
    if ! cp -r "$exec_profile_dir"/* "$temp_opencode_dir/" 2>/dev/null; then
      echo -e "${YELLOW}Error: Failed to copy profile files${NC}" >&2
      exit 1
    fi

    # Save profile metadata in temp .opencode
    current_timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    origin_hash=$(calculate_profile_hash "$exec_profile_dir")

    cat >"$temp_opencode_dir/oc.json" <<EOF
{
  "name": "$exec_profile_name",
  "source": "$exec_profile_dir",
  "updated_at": "$current_timestamp",
  "origin_hash": "$origin_hash"
}
EOF

    # Change to temp directory and execute command
    cd "$temp_dir" || {
      cleanup_temp_environment
      exit 1
    }
    PROJECT_CONFIG_DIR="$temp_opencode_dir"
    PROFILE_METADATA_FILE="$temp_opencode_dir/oc.json"
    export PROJECT_CONFIG_DIR PROFILE_METADATA_FILE

    # Execute the command
    "$@"
    exit $?
    ;;
  use)
    if [[ $# -lt 2 ]]; then
      # No profile name given, show interactive menu
      if [[ -d "$PROJECT_CONFIG_DIR" ]]; then
        show_menu
      else
        show_menu "Select OpenCode configuration to initialize the project with"
      fi
    else
      # Shift past 'use'
      shift
      profile_name="$1"

      switch_to_profile "$profile_name" "false"
    fi
    ;;
  *)
    # Unknown subcommand, show interactive menu as before
    if [[ -d "$PROJECT_CONFIG_DIR" ]]; then
      show_menu
    else
      show_menu "Select OpenCode configuration to initialize the project with"
    fi
    ;;
  esac
else
  # No arguments, show interactive menu
  if [[ -d "$PROJECT_CONFIG_DIR" ]]; then
    show_menu
  else
    show_menu "Select OpenCode configuration to initialize the project with"
  fi
fi
