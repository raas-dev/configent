#!/bin/bash

# oc: Switch OpenCode configuration profiles

# Based on:
# https://github.com/AnPod/Switch-Omo-Config/blob/v1.09/switch-omo-config.sh

# Save the original directory early
ORIGINAL_DIR="$PWD"

# Cleanup function for temporary directories and state
cleanup_temp_environment() {
  local exit_code=$?

  # Always return to original directory if we changed it
  if [[ "$PWD" != "$ORIGINAL_DIR" ]]; then
    cd "$ORIGINAL_DIR" 2>/dev/null || true
  fi

  # Clean up any temporary directories
  if [[ -n "$TEMP_DIR_TO_CLEAN" && -d "$TEMP_DIR_TO_CLEAN" ]]; then
    rm -rf "$TEMP_DIR_TO_CLEAN"
  fi

  return "$exit_code"
}

# Check if we're being called as 'oc exec' and if so, handle it specially
# This avoids the .opencode check that happens at script load time
if [[ "$1" == "exec" && $# -ge 3 ]]; then
  shift # Remove 'exec'
  profile_name="$1"
  shift

  # Check for '--' separator
  if [[ "$1" != "--" ]]; then
    echo "Error: Expected '--' after profile name." >&2
    exit 1
  fi
  shift # Remove '--'

  # Now handle exec_in_profile at the very start, before any other initialization
  CENTRAL_CONFIG_DIR="$HOME/.config/opencode"
  PROFILES_DIR="$CENTRAL_CONFIG_DIR/profile"

  # Verify profile exists
  profile_dir="$PROFILES_DIR/$profile_name"
  if [[ ! -d "$profile_dir" ]]; then
    echo "Error: Profile '$profile_name' not found in $PROFILES_DIR" >&2
    exit 1
  fi

  # Create temporary directory
  temp_dir=$(mktemp -d) || {
    echo "Error: Failed to create temporary directory" >&2
    exit 1
  }

  # Set up cleanup on exit, ensuring we return to original directory
  TEMP_DIR_TO_CLEAN="$temp_dir"
  trap cleanup_temp_environment EXIT TERM

  # Create .opencode directory in temp environment
  temp_opencode_dir="$temp_dir/.opencode"
  mkdir -p "$temp_opencode_dir" || {
    echo "Error: Failed to create .opencode directory in temp environment" >&2
    exit 1
  }

  # Copy profile files to temporary .opencode
  if ! cp -r "$profile_dir"/* "$temp_opencode_dir/" 2>/dev/null; then
    echo "Error: Failed to copy profile files" >&2
    exit 1
  fi

  # Save profile metadata in temp .opencode
  current_timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

  cat >"$temp_opencode_dir/oc.json" <<EOF
{
  "name": "$profile_name",
  "source": "$profile_dir",
  "updated_at": "$current_timestamp"
}
EOF

  # Change to temp directory and execute command
  cd "$temp_dir" || {
    cleanup_temp_environment
    exit 1
  }
  PROJECT_CONFIG_DIR="$temp_opencode_dir"
  PROFILE_METADATA_FILE="$temp_opencode_dir/oc.json"
  export PROJECT_CONFIG_DIR PROFILE_METADATA_FILE

  # Execute the command
  "$@"
  exit $?
fi

# Portable hash function
hash_file() {
  local file="$1"
  if [[ "$OSTYPE" == "darwin"* ]]; then
    md5 -q "$file" 2>/dev/null
  else
    md5sum "$file" 2>/dev/null | awk '{print $1}'
  fi
}

CENTRAL_CONFIG_DIR="$HOME/.config/opencode"
PROFILES_DIR="$CENTRAL_CONFIG_DIR/profile"
PROJECT_ROOT_DIR="$PWD"
PROJECT_CONFIG_DIR="${PROJECT_CONFIG_DIR:-$PROJECT_ROOT_DIR/.opencode}"

# Validate commands early to show errors before any prompts
# This check must happen before the .opencode prompt
if [[ "$1" == "use" && $# -lt 2 ]]; then
  # Compute color codes early for error messages
  YELLOW='\033[1;33m'
  DIM='\033[2m'
  NC='\033[0m'
  echo -e "${YELLOW}Error: use requires a profile name.${NC}" >&2
  echo -e "${DIM}Usage: oc use <profile-name> [--yes]${NC}" >&2
  exit 1
elif [[ "$1" == "exec" && $# -lt 3 ]]; then
  # Compute color codes early for error messages
  YELLOW='\033[1;33m'
  DIM='\033[2m'
  NC='\033[0m'
  echo -e "${YELLOW}Error: exec requires a profile name and a command.${NC}" >&2
  echo -e "${DIM}Usage: oc exec <profile-name> -- command and args${NC}" >&2
  exit 1
fi

# Determine if we should skip the .opencode prompt
# Skip if: in temporary environment (PROFILE_METADATA_FILE set), or using --yes flag
SKIP_OPENCODE_PROMPT=false
if [[ -n "$PROFILE_METADATA_FILE" ]]; then
  SKIP_OPENCODE_PROMPT=true
elif [[ "$1" == "use" && ("$3" == "--yes" || "$3" == "-y") ]]; then
  SKIP_OPENCODE_PROMPT=true
elif [[ "$1" == "exec" ]]; then
  SKIP_OPENCODE_PROMPT=true
fi

# Skip .opencode directory check if we're in a temporary environment (oc exec)
# This is indicated by PROFILE_METADATA_FILE being set
if [[ "$SKIP_OPENCODE_PROMPT" == "true" ]]; then
  # Create .opencode directory silently if it doesn't exist
  if [[ ! -d "$PROJECT_CONFIG_DIR" ]]; then
    mkdir -p "$PROJECT_CONFIG_DIR" 2>/dev/null || true
  fi
elif [[ ! -d "$PROJECT_CONFIG_DIR" ]]; then
  # Prompt to create .opencode if it doesn't exist
  echo "No .opencode directory detected in current directory: $PROJECT_ROOT_DIR"
  read -r -p "Create .opencode directory here for project-scope configuration? [Y/n] " create_opencode
  if [[ ! "$create_opencode" =~ ^[Nn]$ ]]; then
    if ! mkdir -p "$PROJECT_CONFIG_DIR" 2>/dev/null; then
      echo "Error: Failed to create $PROJECT_CONFIG_DIR (check permissions)"
      exit 1
    fi
  else
    exit 0
  fi
fi

# Colors
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m' # No Color

PROFILE_METADATA_FILE="$PROJECT_CONFIG_DIR/oc.json"

# Calculate hash of all files in a directory (including nested files)
calculate_profile_hash() {
  local profile_dir="$1"
  local combined_hash=""

  # Sort files recursively and calculate combined hash
  while IFS= read -r file; do
    if [[ -f "$file" ]]; then
      combined_hash+=$(hash_file "$file")
    fi
  done < <(find "$profile_dir" -type f | sort)

  # Return hash of the combined hashes
  if [[ "$OSTYPE" == "darwin"* ]]; then
    echo "$combined_hash" | md5
  else
    echo "$combined_hash" | md5sum | awk '{print $1}'
  fi
}

# Save profile metadata
save_profile_metadata() {
  local profile_name="$1"
  local profile_dir="$2"

  local current_timestamp
  current_timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

  local origin_hash
  origin_hash=$(calculate_profile_hash "$profile_dir")

  cat >"$PROFILE_METADATA_FILE" <<EOF
{
  "name": "$profile_name",
  "source": "$profile_dir",
  "updated_at": "$current_timestamp",
  "origin_hash": "$origin_hash"
}
EOF
}

# Extract JSON value by key (portable)
json_get_value() {
  local file="$1"
  local key="$2"

  grep -o "\"$key\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" "$file" 2>/dev/null | cut -d'"' -f4
}

# Load profile metadata
load_profile_metadata() {
  if [[ ! -f "$PROFILE_METADATA_FILE" ]]; then
    echo ""
    return
  fi

  # Extract profile name from JSON
  json_get_value "$PROFILE_METADATA_FILE" "name"
}

# Get list of profile directories
get_configs() {
  find -L "$PROFILES_DIR" -maxdepth 1 -mindepth 1 -type d | sort
}

# Calculate hash of project config files (including nested files)
calculate_project_hash() {
  local combined_hash=""

  # Sort files recursively and calculate combined hash
  while IFS= read -r file; do
    if [[ -f "$file" ]]; then
      combined_hash+=$(hash_file "$file")
    fi
  done < <(find "$PROJECT_CONFIG_DIR" -type f | sort)

  # Return hash of the combined hashes
  if [[ "$OSTYPE" == "darwin"* ]]; then
    echo "$combined_hash" | md5
  else
    echo "$combined_hash" | md5sum | awk '{print $1}'
  fi
}

# Get current active profile by checking metadata file first, then comparing hashes
get_current() {
  # First, check if metadata file exists and is valid
  local metadata_profile
  metadata_profile=$(load_profile_metadata)

  if [[ -n "$metadata_profile" ]]; then
    # If metadata profile directory exists, return it (trust the metadata)
    local metadata_dir="$PROFILES_DIR/$metadata_profile"
    if [[ -d "$metadata_dir" ]]; then
      echo "$metadata_profile"
      return
    fi
  fi

  # Calculate project hash once for comparison
  local project_hash
  project_hash=$(calculate_project_hash)

  # If metadata is invalid or missing, find which profile directory matches the current project config
  while IFS= read -r profile_dir; do
    local profile_name
    profile_name=$(basename "$profile_dir")

    # Compare combined hashes instead of individual files
    local profile_hash
    profile_hash=$(calculate_profile_hash "$profile_dir")

    if [[ "$profile_hash" == "$project_hash" ]]; then
      echo "$profile_name"
      return
    fi
  done < <(get_configs)
  echo ""
}

# Switch to a specific profile with confirmations
switch_to_profile() {
  local profile_name="$1"
  local force_yes="$2"

  # Verify profile exists
  local profile_dir="$PROFILES_DIR/$profile_name"
  if [[ ! -d "$profile_dir" ]]; then
    echo -e "${YELLOW}Error: Profile '$profile_name' not found in $PROFILES_DIR${NC}" >&2
    exit 1
  fi

  echo ""

  local current
  current=$(get_current)

  if [[ "$profile_name" == "$current" ]]; then
    # Check if the origin profile has been updated since it was last copied
    local metadata_file="$PROJECT_CONFIG_DIR/oc.json"
    if [[ -f "$metadata_file" ]]; then
      # Extract stored hash and source path from metadata
      local stored_hash
      stored_hash=$(json_get_value "$metadata_file" "origin_hash")
      local source_path
      source_path=$(json_get_value "$metadata_file" "source")

      # Calculate current hash of the origin profile
      local current_origin_hash
      current_origin_hash=$(calculate_profile_hash "$profile_dir")

      # Only ask for reset if the origin profile hash has changed
      if [[ -n "$stored_hash" && "$stored_hash" != "$current_origin_hash" ]]; then
        local display_path
        display_path="${source_path/#$HOME/~}"
        echo -e "${YELLOW}$profile_name has been updated in the origin ($display_path).${NC}"

        if [[ "$force_yes" != "true" ]]; then
          echo -ne "${YELLOW}Reset from origin (overrides project-specific changes)? [y/N]${NC} "
          read -r reset_profile
          if [[ ! "$reset_profile" =~ ^[Yy]$ ]]; then
            echo -e "${DIM}Cancelled.${NC}"
            exit 0
          fi
        fi
      else
        local display_path
        display_path="${source_path/#$HOME/~}"
        echo -e "${DIM}$profile_name is already active.${NC}"
        echo -e "${DIM}There are no updates in the origin ($display_path).${NC}"
        exit 0
      fi
    fi
  fi

  # Remove conflicting files from the project config directory before copying
  for profile_file in "$profile_dir"/*; do
    if [[ -f "$profile_file" ]]; then
      local filename
      filename=$(basename "$profile_file")
      local basename_no_ext="${filename%.*}"
      local ext="${filename##*.}"

      # Remove any files with the same basename but different extension
      for existing_file in "$PROJECT_CONFIG_DIR"/"$basename_no_ext".*; do
        if [[ -f "$existing_file" ]]; then
          local existing_ext="${existing_file##*.}"
          if [[ "$existing_ext" != "$ext" ]]; then
            rm -f "$existing_file"
          fi
        fi
      done
    fi
  done

  # Copy all files and directories from the selected profile directory to the project config directory
  if cp -r "$profile_dir"/* "$PROJECT_CONFIG_DIR/" 2>/dev/null; then
    # Save profile metadata
    save_profile_metadata "$profile_name" "$profile_dir"

    echo -e "${GREEN}Switched to: ${BOLD}$profile_name${NC}"
    echo -e "${DIM}Copied profile files to: $PROJECT_CONFIG_DIR${NC}"
  else
    echo -e "${YELLOW}Error: Failed to copy profile files${NC}"
    exit 1
  fi
}

# Interactive menu with arrow keys
show_menu() {
  local configs=()
  local names=()

  while IFS= read -r file; do
    configs+=("$file")
    names+=("$(basename "$file")")
  done < <(get_configs)

  if [[ ${#configs[@]} -eq 0 ]]; then
    echo -e "${YELLOW}No profile directories found in $PROFILES_DIR${NC}" >&2
    exit 1
  fi

  local current
  current=$(get_current)
  local selected=0
  local total=${#configs[@]}

  # Find and select the currently active configuration by default
  if [[ -n "$current" ]]; then
    for i in "${!names[@]}"; do
      if [[ "${names[$i]}" == "$current" ]]; then
        selected=$i
        break
      fi
    done
  fi

  # Hide cursor
  tput civis

  # Cleanup on exit
  trap 'tput cnorm; echo' EXIT TERM

  echo -e "${BOLD}Select OpenCode configuration${NC}"
  echo -e "${DIM}Use arrow keys to navigate, Enter to select, q to quit${NC}"
  echo ""

  while true; do
    # Move cursor up to redraw menu
    if [[ $REPLY ]]; then
      tput cuu "$total"
    fi

    # Draw menu
    for i in "${!names[@]}"; do
      local name="${names[$i]}"
      local marker="  "
      local color=""
      local suffix=""

      # Check if this is the currently active config
      if [[ "$name" == "$current" ]]; then
        suffix=" ${GREEN}(active)${NC}"
      fi

      if [[ $i -eq $selected ]]; then
        marker="${YELLOW}>${NC} "
        color="${CYAN}"
        echo -e "${marker}${color}${name}${NC}${suffix}"
      else
        echo -e "  ${DIM}${name}${NC}${suffix}"
      fi
    done

    # Read single keypress
    read -rsn1 key

    # Handle arrow keys (escape sequences)
    if [[ $key == $'\x1b' ]]; then
      read -rsn2 key
      case $key in
      '[A') # Up arrow
        ((selected--))
        [[ $selected -lt 0 ]] && selected=$((total - 1))
        ;;
      '[B') # Down arrow
        ((selected++))
        [[ $selected -ge $total ]] && selected=0
        ;;
      esac
    elif [[ $key == "" ]]; then # Enter
      break
    elif [[ $key == $'\x03' || $key == "q" || $key == "Q" ]]; then # ^C or q
      tput cnorm
      echo ""
      echo -e "${DIM}Cancelled.${NC}"
      exit 0
    elif [[ $key == "j" ]]; then # vim down
      ((selected++))
      [[ $selected -ge $total ]] && selected=0
    elif [[ $key == "k" ]]; then # vim up
      ((selected--))
      [[ $selected -lt 0 ]] && selected=$((total - 1))
    fi

    REPLY=1
  done

  # Show cursor
  tput cnorm

  # Switch to selected profile
  local selected_name="${names[$selected]}"
  switch_to_profile "$selected_name" "false"
}

# Show help message
show_help() {
  printf "%b\n" \
    "${BOLD}oc${NC} - OpenCode configuration manager" \
    "" \
    "${BOLD}USAGE:${NC}" \
    "  oc [COMMAND] [OPTIONS]" \
    "" \
    "${BOLD}COMMANDS:${NC}" \
    "  ${BOLD}(no command)${NC}" \
    "      Show interactive profile selection menu." \
    "" \
    "  ${CYAN}use${NC} <profile-name> [--yes | -y]" \
    "      Switch to the specified profile. Shows confirmation prompts unless" \
    "      --yes or -y flag is provided to skip prompts." \
    "" \
    "      Example:" \
    "        oc use git-use" \
    "        oc use omo-zai -y" \
    "" \
    "  ${CYAN}exec${NC} <profile-name> -- <command> [args...]" \
    "      Execute a command in a temporary environment with the specified profile." \
    "      The profile's .opencode directory is copied to a temp directory." \
    "" \
    "      Example:" \
    "        oc exec git-use -- pwd" \
    "        oc exec omo-zai -- ls -la .opencode/" \
    "" \
    "  ${CYAN}help${NC}, ${CYAN}-h${NC}, ${CYAN}--help${NC}" \
    "      Show this help message." \
    "" \
    "${BOLD}OPTIONS:${NC}" \
    "  -h, --help        Show this help message" \
    "  -y, --yes         Skip confirmation prompts (use command only)" \
    "" \
    "${BOLD}EXAMPLES:${NC}" \
    "  # Interactive mode" \
    "  oc" \
    "" \
    "  # Switch profile with confirmation" \
    "  oc use omo-antigravity" \
    "" \
    "  # Switch profile without confirmation" \
    "  oc use git-use --yes" \
    "" \
    "  # Execute command with profile" \
    "  oc exec git-use -- cat .opencode/oc.json" \
    ""
}

# Execute command in a temporary environment with a specific profile
exec_in_profile() {
  local profile_name="$1"
  shift # Remove profile name from arguments
  local commands=("$@")

  # Verify profile exists
  local profile_dir="$PROFILES_DIR/$profile_name"
  if [[ ! -d "$profile_dir" ]]; then
    echo -e "${YELLOW}Error: Profile '$profile_name' not found in $PROFILES_DIR${NC}" >&2
    exit 1
  fi

  # Verify there are commands to execute
  if [[ ${#commands[@]} -eq 0 ]]; then
    echo -e "${YELLOW}Error: No command provided. Usage: oc exec <profile-name> -- command and args${NC}" >&2
    exit 1
  fi

  # Create temporary directory
  local temp_dir
  temp_dir=$(mktemp -d) || {
    echo -e "${YELLOW}Error: Failed to create temporary directory${NC}" >&2
    exit 1
  }

  # Set up cleanup on exit, ensuring we return to original directory
  TEMP_DIR_TO_CLEAN="$temp_dir"
  trap cleanup_temp_environment EXIT TERM

  # Create .opencode directory in temp environment
  local temp_opencode_dir="$temp_dir/.opencode"
  mkdir -p "$temp_opencode_dir" || {
    echo -e "${YELLOW}Error: Failed to create .opencode directory in temp environment${NC}" >&2
    exit 1
  }

  # Copy profile files to temporary .opencode
  if ! cp -r "$profile_dir"/* "$temp_opencode_dir/" 2>/dev/null; then
    echo -e "${YELLOW}Error: Failed to copy profile files${NC}" >&2
    exit 1
  fi

  # Save profile metadata in temp .opencode
  local current_timestamp
  current_timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
  local origin_hash
  origin_hash=$(calculate_profile_hash "$profile_dir")

  cat >"$temp_opencode_dir/oc.json" <<EOF
{
  "name": "$profile_name",
  "source": "$profile_dir",
  "updated_at": "$current_timestamp",
  "origin_hash": "$origin_hash"
}
EOF

  # Execute command in the temporary environment
  # Change to temp dir and export environment before executing
  cd "$temp_dir" || {
    cleanup_temp_environment
    exit 1
  }
  PROJECT_CONFIG_DIR="$temp_opencode_dir"
  PROFILE_METADATA_FILE="$temp_opencode_dir/oc.json"
  export PROJECT_CONFIG_DIR PROFILE_METADATA_FILE

  # Execute the command in the temp environment
  "${commands[@]}"
  local exit_code=$?

  # Cleanup will handle returning to original directory
  exit "$exit_code"
}

# Parse command-line arguments
if [[ $# -gt 0 ]]; then
  case "$1" in
  help | -h | --help)
    show_help
    ;;
  exec)
    if [[ $# -lt 3 ]]; then
      echo -e "${YELLOW}Error: exec requires a profile name and a command.${NC}" >&2
      echo -e "${DIM}Usage: oc exec <profile-name> -- command and args${NC}" >&2
      exit 1
    fi
    # Shift past 'exec'
    shift
    profile_name="$1"
    shift

    # Check for '--' separator
    if [[ "$1" != "--" ]]; then
      echo -e "${YELLOW}Error: Expected '--' after profile name.${NC}" >&2
      echo -e "${DIM}Usage: oc exec <profile-name> -- command and args${NC}" >&2
      exit 1
    fi
    shift # Remove '--'

    exec_in_profile "$profile_name" "$@"
    ;;
  use)
    if [[ $# -lt 2 ]]; then
      echo -e "${YELLOW}Error: use requires a profile name.${NC}" >&2
      echo -e "${DIM}Usage: oc use <profile-name> [--yes]${NC}" >&2
      exit 1
    fi
    # Shift past 'use'
    shift
    profile_name="$1"
    shift

    # Check for optional --yes or -y flag
    force_yes="false"
    if [[ "$1" == "--yes" ]] || [[ "$1" == "-y" ]]; then
      force_yes="true"
    fi

    switch_to_profile "$profile_name" "$force_yes"
    ;;
  *)
    # Unknown subcommand, show interactive menu as before
    show_menu
    ;;
  esac
else
  # No arguments, show interactive menu
  show_menu
fi
