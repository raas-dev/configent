#!/bin/bash
# the above shebang is only for ShellCheck, this file is not executable

# shellcheck disable=SC2139  # ok to expand skipped_managers at defined-time

### IDE ########################################################################

# export DEFAULT_IDE="<BIN_NAME>" in ~/.rclocal to override what's in .profile
alias code="\$DEFAULT_IDE --reuse-window"

### Upgrade for all package managers ###########################################

skipped_managers="containers helm powershell uv"
alias up="topgrade --disable restarts snap system $skipped_managers"
alias dup="topgrade --disable $skipped_managers"

### OS specific ################################################################

if [ "$(uname -s)" = 'Darwin' ]; then
  # Open Brave Browser with remote debugging enabled
  alias brave='open -a "Brave Browser" --args --remote-debugging-port=9222'

  # Recursively delete .DS_Store files in the current path
  alias cds='/usr/bin/find . -type f -name "*.DS_Store" -ls -delete'

  # Fix macOS keyboard input sources
  alias resetkeyboard="rm -fv ~/Library/Preferences/com.apple.HIToolbox.plist"

  # Get macOS keyboard layout name
  alias kb="defaults read ~/Library/Preferences/com.apple.HIToolbox.plist AppleSelectedInputSources | grep 'KeyboardLayout Name' | cut -f 2 -d '=' | tr -d ' ;.\"'"

  # Disable or enable Spotlight (indexing)
  alias spotoff='sudo mdutil -a -i off'
  alias spoton='sudo mdutil -a -i on'

  # Canonical hex dump; some systems have this symlinked
  ! command -v hd >/dev/null && alias hd='hexdump -C'

  # macOS keychain: get
  gx() {
    local name="$1"
    [ -z "$name" ] && echo "Usage: $0 <name>" && return 1
    security find-generic-password -a "$USER" -D "environment variable" \
      -s "$name" -w
  }

  # macOS keychain: set
  sx() {
    local name="$1"
    [ -z "$name" ] && echo "Usage: $0 <name>" && return 1
    local secret="$2"
    if [ -z "$secret" ]; then
      printf "Enter secret for %s: " "$name"
      read -r secret
    fi
    [ -z "$secret" ] && echo "Error: Empty secret" && return 1
    security add-generic-password -a "$USER" -D "environment variable" \
      -s "$name" -w "$secret" -U
  }

  # macOS keychain: delete
  dx() {
    local name="$1"
    [ -z "$name" ] && echo "Usage: $0 <name>" && return 1
    printf "Are you sure to remove all secret %s [y\N] > " "$1"
    read -r choice
    case "$choice" in
    [yY])
      security delete-generic-password -a "$USER" -D "environment variable" \
        -s "$name"
      ;;
    *)
      printf "Aborted.\n"
      ;;
    esac
  }
else
  # Similar to macOS `pbcopy` and `pbpaste`
  alias pbcopy='xsel --clipboard --input'
  alias pbpaste='xsel --clipboard --output'

  # Similar to macOS `open`
  alias open='xdg-open'
fi

### More sensible defaults #####################################################

alias grep='grep --color'
alias egrep='egrep --color'
alias fgrep='fgrep --color'

alias ping='ping -c 999'

### Safer defaults #############################################################

alias chown='chown --preserve-root'
alias chmod='chmod --preserve-root'
alias chgrp='chgrp --preserve-root'
# rm: --preserve-root is default

### Enhanced ls ################################################################

if command -v lsd >/dev/null; then
  alias ls='lsd --group-dirs first --date="+%a %d-%b-%y %H:%M:%S" --icon never'
  alias la='ls -Al'
  alias le='ls -Al --extensionsort && echo Ordered by extension, alphabetically'
  alias lu='ls -Al --sizesort && echo Ordered by size, biggest first'
  alias lt='ls -Al --timesort && echo Ordered by change time, most recent first'
  alias lut='ls -Al --sizesort --total-size --tree --depth 2'
  alias tree='ls --tree'
else
  alias ls='ls --color -h'
  alias la='ls -Al'
  alias le='ls -Al -XB && echo Ordered by extension, alphabetically'
  alias lu='ls -Al -S && echo Ordered by size, biggest first'
  alias lt='ls -Al -tc && echo Ordered by change time, most recent first'
fi

### Shortcuts ##################################################################

alias a='ai'
alias b='bat --style grid,header,snip --paging never'
alias c='oxker --host $DOCKER_HOST'
# d is for generic docker build and run, see d()
alias e="\$DEFAULT_IDE --add"
alias f='fd --ignore-case --no-ignore --hidden --glob'
# g is for git/gitui, see g()
alias h='xh --verify=no'
alias i='glances'
# j is for zoxide
alias k='kalk'
alias l='la'
# m is for m-cli
# n is for ad-hoc nix-shell in docker, see n()
alias o='open'
alias p='procs --pager always --tree'
alias q='clear'
alias r='exec $SHELL'
alias s='rg --smart-case --hidden --glob \!.git/ --fixed-strings'
# t is for tail logs, see t()
alias u='dust'
# v is for limactl wrapper, see v()
alias w='which -a'
alias x='pkill -i -f'
alias y='tldr'
alias z='witr'
alias §='trans :fi'
alias \?='trans'
alias \#='echo'
alias ¨='bat --show-all'
alias ,='mise_exec'
alias _='oc_agent'

### Privileged utilities #######################################################

# Enable aliases to be sudo'ed
alias sudo='sudo '

# tailspin
alias ts='$(which tspin) --print --follow'

# viddy
if command -v viddy >/dev/null; then
  alias watch='$(which viddy) --differences --no-title'
fi

### Lima VMs ###################################################################

v() {
  if [ -n "$1" ]; then
    local command="$1"
    shift
  else
    local command="help"
  fi

  if [ -n "$1" ]; then
    local template="$1"
    shift
    local vm_name="$template"
  else
    local template="debian"
    local vm_name="default"
  fi

  for arg in "$@"; do
    if [[ "$arg" == "--name="* ]]; then
      vm_name="${arg#--name=}"
      break
    elif [[ "$arg" == "--name" ]]; then
      shift
      vm_name="$1"
      break
    fi
  done

  case "$command" in
  up | start)
    if ! limactl list --json | grep -q "\"$vm_name\".*\"status\": *\"Running\""; then
      local os_create_args=()
      local os_start_args=()
      if [ "$(uname -s)" = 'Darwin' ]; then
        if [ -x "/opt/socket_vmnet/bin/socket_vmnet" ]; then
          os_create_args=(--vm-type=vz --network=lima:bridged --rosetta)
          os_start_args=(--network=lima:bridged --rosetta)
        else
          os_create_args=(--vm-type=vz --network=vzNAT --rosetta)
          os_start_args=(--network=vzNAT --rosetta)
        fi
      fi
      limactl start "$HOME/.config/configent/lima/$template.yaml" \
        --name "$vm_name" --tty=false \
        "${os_create_args[@]}" \
        --set=".env.GITHUB_TOKEN = \"$GITHUB_TOKEN\"" \
        "$@" ||
        limactl start "$vm_name" \
          --tty=false \
          "${os_start_args[@]}" \
          --set=".env.GITHUB_TOKEN = \"$GITHUB_TOKEN\"" \
          "$@"
    fi
    limactl shell "$vm_name"
    ;;
  shell | run | exec | s)
    limactl shell "$vm_name" "$@"
    ;;
  down | stop)
    limactl stop "$vm_name" --force
    ;;
  delete | del | rm)
    limactl stop "$vm_name" --force
    limactl delete "$vm_name" --force
    ;;
  prune)
    limactl prune
    ;;
  *)
    echo "Usage: v <up|shell|down|delete> <vm_name> [lima_args]"
    echo ""
    limactl list 2>/dev/null
    ;;
  esac
}

# start vm in development mode
vv() {
  if [[ "$1" == "up" || "$1" == "start" ]]; then
    if [ $# -eq 1 ] || [[ "$2" == --* ]]; then
      # Check if user already specified --name
      local has_name=false
      for arg in "${@:2}"; do
        if [[ "$arg" == --name=* || "$arg" == --name ]]; then
          has_name=true
          break
        fi
      done
      if [ "$has_name" = false ]; then
        v "$1" debian --name=default "${@:2}" --set=.env.GIT_REF=\"main\"
      else
        v "$1" debian "${@:2}" --set=.env.GIT_REF=\"main\"
      fi
    else
      v "$@" --set=.env.GIT_REF=\"main\"
    fi
  else
    v "$@"
  fi
}

# copy kubectl config from lima vm
kubeconfig() {
  if [ -n "$1" ]; then
    local vm_name="$1"
  else
    local vm_name="default"
  fi
  limactl copy "$vm_name":~/.kube/config "$HOME/.lima/$vm_name/kubeconfig.yaml"
}

### docker #####################################################################

alias dr='docker rm --force $(docker ps --all --quiet)'
alias drv='docker volume rm --force $(docker volume ls --quiet)'
alias dri='docker rmi --force $(docker images --all --quiet)'
alias dpr='dr ; drv ; dri ; docker system prune --force --volumes'

### nerdctl ####################################################################

alias nr='nerdctl rm --force $(nerdctl ps --all --quiet)'
alias nrv='nerdctl volume rm --force $(nerdctl volume ls --quiet)'
alias nri='nerdctl rmi --force $(nerdctl images --all --quiet)'
alias npr='nr ; nrv ; nri ; nerdctl system prune --force --volumes'

### podman #################################################################

alias pr='podman rm --force $(podman ps --all --quiet)'
alias prv='podman volume rm --force $(podman volume ls --quiet)'
alias pri='podman rmi --force $(podman images --all --quiet)'
alias ppr='pr ; prv ; pri ; podman system prune --force --volumes'

### Utilities ##################################################################

# cd
alias cdtemp='cd $(mktemp -d)'

# Typos
alias dc='cd'
alias gt='git'
alias gti='git'

# Copy the current path to clipboard
alias cwd='pwd | tr -d "\n" | pbcopy'

# Print columns to measure terminal width
alias c80='printf "%.0s-" $(seq 80)'
alias c90='printf "%.0s-" $(seq 90)'

# Display public DNS server
alias dns='dig +short whoami.akamai.net'

# Display public IP
alias ip='curl --silent --ipv4 https://whatismyhostname.com/json/ | jq .'
alias ipv4='curl --silent --ipv4 ifconfig.me -w "\n"'
alias ipv6='curl --silent --ipv6 ifconfig.me -w "\n"'

# Display PATH content
alias path='printf "${PATH//:/\\n}\n"'

# Display week number
alias week='date +%V'

### Ad-hoc TUI apps ###########################################################

# Terminal disk space navigator
alias diskonaut='mise exec cargo:diskonaut -- diskonaut'

# A tool for exploring each layer in a docker image
alias dive='mise exec dive -- dive'

# Ping, but with a graph
alias gping='mise exec gping -- gping'

# Kubernetes TUI
alias k9s='mise exec k9s -- k9s'

# Lazyjournal is a TUI log viewer for journalctl
alias lazyjournal='mise exec lazyjournal -- lazyjournal'

# Build complex nmap commands with an intuitive TUI
alias lazynmap='mise exec cargo:lazynmap -- lazynmap'

# A terminal UI wrapper for Trivy
alias lazytrivy='mise exec github:owenrumney/lazytrivy -- lazytrivy'

# Terminal network scanner & diagnostic tool with modern TUI
alias netscanner='mise exec cargo:netscanner -- netscanner'

# A network diagnostic tool
alias trip='mise exec github:fujiapple852/trippy -- trip'

# A fast terminal Excel viewer with an interactive TUI
alias xleak='mise exec github:bgreenwell/xleak -- xleak'

### Python #####################################################################

# https://github.com/subash774/Caffeinate
alias awake='uvx --from caffeinate awake --time 540'

# Converting files and office documents to Markdown
alias markitdown='uvx --from "markitdown[all]" markitdown'

# HTTP API client
alias posting='POSTING_THEME="hypernova" uvx posting'

# General media downloader
alias you-get='uvx you-get'

### sast

# Bandit (Python security linter - add toml for -c pyproject.toml support)
alias bandit='uvx "bandit[toml]"'

# Checkov (cloud misconfiguration scanner)
alias checkov='uvx checkov'

# GuardDog (malicious package identifier - uses semgrep underneath)
alias guarddog='uvx guarddog'

# Markdown linter and formatter inspired by ruff
alias rumdl='uvx rumdl'

# Semgrep (code vulnerability scanner)
alias semgrep='uvx semgrep'

### ai

# Huggingface CLI
alias huggingface-cli='uvx --from huggingface-hub huggingface-cli'

# Reactive notebook
alias marimo='uvx marimo'

# AI agent resource security scanner (https://github.com/snyk/agent-scan)
alias mcpscan='uvx mcp-scan'

# Create Agent Skills from repositories, docs (https://skillseekersweb.com)
alias skill-seekers='uvx skill-seekers'

# GitHub Spec Kit (best for greenfield projects, see OpenSpec for others)
alias specify='uvx --from specify-cli specify'

### dev

# Command-line utility for rendering projects templates
alias copier='uvx --with copier-templates-extensions copier'

# SQL IDE for terminal
alias harlequin='uvx --from "harlequin[mysql,postgres,odbc]" harlequin'

# https://hatch.pypa.io/latest
alias hatch='uvx hatch'

# Toggle a Python virtual environment for development
venv() {
  # shellcheck disable=SC1091  # activate does not exist unless venv is created
  if [ -z "$VIRTUAL_ENV" ]; then
    [ ! -d ".venv" ] && uv venv --seed # python -m venv .venv
    source ".venv/bin/activate"
    sitepackages_path="$(python -c 'import sysconfig; print(sysconfig.get_paths()["purelib"])')"
    ln -sfnv "$HOME/.config/configent/python/sitecustomize.py" \
      "$sitepackages_path/sitecustomize.py"
    uv pip install ptpython rich
    if [ -r "pdm.lock" ] && command -v pdm >/dev/null; then
      pdm install
    elif [ -r "poetry.lock" ] && command -v poetry >/dev/null; then
      ! poetry check &>/dev/null && poetry lock
      poetry install
    elif [ -r "uv.lock" ] && [ -r "pyproject.toml" ]; then
      # inexact: do not remove extraneous packages unless they conflict
      uv sync --inexact --all-extras
    else
      # no lockfile, do not create one either
      # prioritize requirements.txt as it most likely has pinned dependencies
      if [ -r "requirements.txt" ]; then
        uv pip install -r requirements.txt
      elif [ -r "pyproject.toml" ]; then
        uv pip install --all-extras -r pyproject.toml
      elif [ -r "setup.py" ]; then
        uv pip install --all-extras -r setup.py
      fi
      if [ -r "pyproject.toml" ] || [ -r "setup.py" ]; then
        uv pip install --editable .
      fi
    fi
  else
    deactivate
    if [ "$1" = "-f" ] || [ "$1" = "--force" ]; then
      [ -d ".venv" ] && rm -rv ".venv"
      shift
    fi
  fi
}

### Node.js ####################################################################

# MCP server development tool
alias inspector='bunx @modelcontextprotocol/inspector'

# MCP apps development tool
alias mcpjam='bunx @mcpjam/inspector'

# Call MCP servers from CLI
alias mcporter='bunx mcporter'

# Upgrades your package.json dependencies to the latest version
alias ncu='bunx npm-check-updates'

# OpenSpec (best for existing codebases, see Github Spec Kit for greenfield)
alias openspec='bunx @fission-ai/openspec'

# Shorthand for pnpm
alias pn='bunx pnpm'

# Project generator
alias projen='bunx projen'

# LLM evaluation framework
alias promptfoo='bunx promptfoo'

# Packs entire repository into a single, AI-friendly file
alias repomix='bunx repomix'

# skills-installer (https://claude-plugins.dev/skills)
alias skills-installer='bunx skills-installer'

### AI #########################################################################

ai() {
  if [ -n "$1" ]; then
    oc exec chat -- opencode run --agent chat "$@"
  else
    oc exec chat -- opencode --agent chat
  fi
}

oc_agent() {
  if [ -n "$1" ]; then
    local agent="$1"
    shift
  else
    local agent="computer-use"
  fi

  oc exec "$agent" -- opencode --agent "$agent" "$@"
}

## openchamber
alias occ='mise exec npm:@openchamber/web -- openchamber serve --daemon'
alias ocs='mise exec npm:@openchamber/web -- openchamber stop'

### Docker ####################################################################

# Generic docker build and run
d() {
  # lowercase the image name to allow pushing it to container registries
  # shellcheck disable=SC2155  # will not declare separately, value compactness
  local name="$(echo "${PWD##*/}" | tr '[:upper:]' '[:lower:]')"
  if docker top "$name" &>/dev/null; then
    docker stop "$name" || docker kill "$name"
  fi

  if [ -r "$PWD/Dockerfile" ]; then
    echo "[d] Building image from Dockerfile"
    docker build --pull --tag "$name" . || return
  else
    echo "[d] Building image with nixpacks"
    TMPDIR="/tmp/lima" nixpacks build . --name "$name" || return
  fi

  if [ -n "$PORT" ]; then
    local port_args=""
    local first_port=""

    # Split PORT by comma and create publish args for each
    local remaining_ports="$PORT"
    while [ -n "$remaining_ports" ]; do
      if [ "$remaining_ports" != "${remaining_ports#*,}" ]; then
        # Contains comma, extract first port
        local port="${remaining_ports%%,*}"
        remaining_ports="${remaining_ports#*,}"
      else
        # No more commas, this is the last port
        local port="$remaining_ports"
        remaining_ports=""
      fi

      # Trim whitespace and skip empty ports
      port=$(echo "$port" | xargs)
      if [ -n "$port" ]; then
        port_args="$port_args --publish 127.0.0.1:$port:$port"
        # Use first valid port as the main PORT env var for the container
        if [ -z "$first_port" ]; then
          first_port="$port"
        fi
      fi
    done

    # Pass only the first port as PORT env var to the container
    local env_args="--env PORT=$first_port"

    # Debug: show what we're setting
    echo "[d] Port mappings: $port_args"
    echo "[d] Container PORT env: $first_port"
  fi

  [ -r "$PWD/.env" ] && local env_file="--env-file $PWD/.env"

  if [ -n "$1" ] && [ "$1" != "-d" ] && [ "$1" != "--detach" ]; then
    local run_args="--log-driver none --entrypoint /bin/sh"
    local cmd="-c '$*'"
  else
    local run_args="$*"
  fi

  eval docker run --init -it --name "$name" --rm \
    --cap-drop ALL \
    "$port_args" \
    "$env_file" \
    "$env_args" \
    "$run_args" \
    "$name" "$cmd"

  local run_exit_code=$?

  if [ "$run_args" = "-d" ] || [ "$run_args" = "--detach" ]; then
    echo "[d] Published ports: container -> host"
    docker port "$name"
    echo "[d] Following logs, ^C does not halt the container"
    docker logs --follow "$name"
  fi

  return $run_exit_code
}

### Utilities ##################################################################

# More inclusive ripgrep, see alias `s`
alias ss='rg --smart-case --no-ignore --hidden --glob \!.git/ --fixed-strings'

# Generic extract package
ext() {
  # Forked from: https://github.com/xvoland/Extract/blob/master/extract.sh
  if [ $# -eq 0 ]; then
    echo "Usage: $0 <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz|.zlib|.cso|.whl>"
    echo "       $0 <path/file_name_1.ext> [path/file_name_2.ext] [path/file_name_3.ext]"
  fi

  for n in "$@"; do
    if [ ! -f "$n" ]; then
      echo "[e] File does not exist: $n"
      return 1
    fi

    case "${n%,}" in
    *.cbt | *.tar.bz2 | *.tar.gz | *.tar.xz | *.tbz2 | *.tgz | *.txz | *.tar)
      tar zxvf "$n"
      ;;
    *.lzma) unlzma ./"$n" ;;
    *.bz2) bunzip2 ./"$n" ;;
    *.cbr | *.rar) unrar x -ad ./"$n" ;;
    *.gz) gunzip ./"$n" ;;
    *.cbz | *.epub | *.zip | *.whl) unzip ./"$n" ;;
    *.z) uncompress ./"$n" ;;
    *.7z | *.apk | *.arj | *.cab | *.cb7 | *.chm | *.deb | *.iso | *.lzh | *.msi | *.pkg | *.rpm | *.udf | *.wim | *.xar | *.vhd)
      7zz x ./"$n"
      ;;
    *.xz) unxz ./"$n" ;;
    *.exe) cabextract ./"$n" ;;
    *.cpio) cpio -id <./"$n" ;;
    *.cba | *.ace) unace x ./"$n" ;;
    *.zpaq) zpaq x ./"$n" ;;
    *.arc) arc e ./"$n" ;;
    *.cso) ciso 0 ./"$n" ./"$n.iso" &&
      extract "$n.iso" && \rm -f "$n" ;;
    *.zlib) zlib-flate -uncompress <./"$n" >./"$n.tmp" &&
      mv ./"$n.tmp" ./"${n%.*zlib}" && rm -f "$n" ;;
    *.dmg)
      hdiutil mount ./"$n" -mountpoint "./$n.mounted"
      ;;
    *)
      echo "[e] Unknown archive: $n"
      return 1
      ;;
    esac
  done
}

# Shortcut for git, opens gitui log view by default
g() {
  if [ $# -eq 0 ]; then
    gitui
  else
    git "$@"
  fi
}

# Generate password and copy it to clipboard
genpass() {
  local length="${1:-16}"
  tr </dev/urandom -dc 'a-zA-Z0-9-_!@#$%^&*()_+{}|:<>?=' |
    fold -w "$length" | head -n1 | pbcopy
}

# Scientific calculator with support for physical units
kalk() {
  # https://numbat.dev/
  if [ $# -eq 0 ]; then
    numbat
  else
    numbat --expression "$*"
  fi
}

# Shortcut to execute ad-hoc commands
mise_exec() {
  # shellcheck disable=SC2155  # will not declare separately, value compactness
  local first_match="$(mise search --match-type contains "$1" 2>/dev/null |
    head -1 | awk '{print $1}')"
  if [ -n "$first_match" ]; then
    local first_arg="$1"
    shift
    if [ "$1" = "--" ]; then
      mise exec "$first_match" "$@"
    else
      mise exec "$first_match" -- "$first_arg" "$@"
    fi
  else
    mise exec "$@"
  fi
}

# List what listens on port(s, separated by comma)
port() {
  local filter=
  [ -n "$1" ] && filter=":$1"
  lsof -P -iTCP"$filter" -sTCP:LISTEN +c0
}

ports() {
  local filter=
  [ -n "$1" ] && filter=":$1"
  sudo lsof -P -iTCP"$filter" -sTCP:LISTEN +c0
}

# Weather (https://github.com/chubin/wttr.in)
wttr() {
  local city="${1:-$(ipv4 | jq -r .city)}"
  curl "v2.wttr.in/${city}?MF&lang=en"
}

### Logs #######################################################################

# Follow logs with (multi)tail
t() {
  local args="${*:-*.log}"
  local needs_sudo=false

  # Check if any of the arguments need sudo (not readable)
  # For globs, check if any matching files exist and are readable
  # Portable approach that works in both bash and zsh
  if [ $# -eq 0 ]; then
    # Default case: check if any .log files are readable
    local found_files=false
    # Use a portable method to check glob expansion
    # In zsh, use $~ to expand globs; in bash, globs expand automatically
    if [ -n "${ZSH_VERSION:-}" ]; then
      setopt localoptions null_glob
      for file in *.log; do
        found_files=true
        if [ ! -r "$file" ] 2>/dev/null; then
          needs_sudo=true
          break
        fi
      done
    else
      # bash: save nullglob state, enable it, then restore
      local nullglob_was_set=false
      if shopt -q nullglob 2>/dev/null; then
        nullglob_was_set=true
      fi
      shopt -s nullglob
      for file in *.log; do
        found_files=true
        if [ ! -r "$file" ] 2>/dev/null; then
          needs_sudo=true
          break
        fi
      done
      if [ "$nullglob_was_set" = false ]; then
        shopt -u nullglob
      fi
    fi
    # If no files found, might need sudo
    if [ "$found_files" = false ]; then
      needs_sudo=true
    fi
  else
    # Check each argument
    for arg in "$@"; do
      # Handle globs
      if [[ "$arg" == *"*"* ]] || [[ "$arg" == *"?"* ]]; then
        local found_files=false
        if [ -n "${ZSH_VERSION:-}" ]; then
          setopt localoptions null_glob
          # In zsh, expand glob pattern first, then iterate
          local expanded_files
          # shellcheck disable=SC2295  # $~ is zsh-specific glob expansion syntax
          expanded_files=($~arg)
          for file in "${expanded_files[@]}"; do
            found_files=true
            if [ ! -r "$file" ] 2>/dev/null; then
              needs_sudo=true
              break 2
            fi
          done
        else
          # bash: save nullglob state, enable it, then restore
          local nullglob_was_set=false
          if shopt -q nullglob 2>/dev/null; then
            nullglob_was_set=true
          fi
          shopt -s nullglob
          for file in $arg; do
            found_files=true
            if [ ! -r "$file" ] 2>/dev/null; then
              needs_sudo=true
              break 2
            fi
          done
          if [ "$nullglob_was_set" = false ]; then
            shopt -u nullglob
          fi
        fi
        # If no files found, might need sudo
        if [ "$found_files" = false ]; then
          needs_sudo=true
          break
        fi
      else
        # Regular file
        if [ ! -r "$arg" ] 2>/dev/null; then
          needs_sudo=true
          break
        fi
      fi
    done
  fi

  if command -v multitail >/dev/null; then
    local opts="-CT ansi"

    # shellcheck disable=SC2086  # must be without quotes to expand args
    if [ "$(tput lines)" -lt 23 ] || [ "$(tput cols)" -lt 78 ]; then
      # Dismiss "Terminal too small" popup via expect
      local exp='set timeout 1; spawn -noecho multitail '"$opts"' '"$args"'; expect "Terminal too small" { after 1; send "\r" }; interact'
      if [ "$needs_sudo" = true ]; then
        sudo expect -c "$exp"
      else
        expect -c "$exp"
      fi
    elif [ "$needs_sudo" = true ]; then
      eval sudo multitail $opts $args
    else
      eval multitail $opts $args
    fi
  else
    # shellcheck disable=SC2086
    if [ "$needs_sudo" = true ]; then
      eval sudo tail --follow --verbose --lines=20 $args
    else
      eval tail --follow --verbose --lines=20 $args
    fi
  fi
}

# Follow logs with lnav (present on most Linux distros' repositories)
tl() {
  if ! command -v lnav >/dev/null; then
    echo "Error: lnav is not installed" >&2
    return 127
  fi

  local files=()
  local needs_sudo=false

  # If no arguments, use default file
  if [ $# -eq 0 ]; then
    files=("/var/log/cloud-init-output.log")
  else
    # Expand all arguments (including glob patterns) and collect files
    for arg in "$@"; do
      # Expand glob pattern if it contains wildcards
      if [[ "$arg" == *"*"* ]] || [[ "$arg" == *"?"* ]]; then
        # Use nullglob to handle cases where no files match (shell-specific)
        if [ -n "$ZSH_VERSION" ]; then
          # zsh: use $~arg to force glob expansion
          setopt nullglob
          # In zsh, expand glob pattern first, then iterate
          local expanded_files
          # shellcheck disable=SC2295  # $~ is zsh-specific glob expansion syntax
          expanded_files=($~arg)
          for file in "${expanded_files[@]}"; do
            files+=("$file")
          done
          unsetopt nullglob
        elif [ -n "$BASH_VERSION" ]; then
          # bash
          shopt -s nullglob
          for file in $arg; do
            files+=("$file")
          done
          shopt -u nullglob
        else
          # fallback: expand without nullglob (may include literal pattern if no match)
          for file in $arg; do
            # Only add if it's an actual file (not the literal pattern)
            [ -e "$file" ] && files+=("$file")
          done
        fi
      else
        files+=("$arg")
      fi
    done
  fi

  # Check if any files need sudo access
  for file in "${files[@]}"; do
    if [ ! -r "$file" ]; then
      needs_sudo=true
      break
    fi
  done

  # Build lnav command with all files
  local lnav_cmd=(
    lnav
    -c ':config /ui/theme night-owl'
    -c ':config /ui/mouse/mode enabled'
    -c ':goto -1'
  )

  # Add all files to the command
  lnav_cmd+=("${files[@]}")

  # Execute with or without sudo
  if [ "$needs_sudo" = true ]; then
    sudo "${lnav_cmd[@]}"
  else
    "${lnav_cmd[@]}"
  fi
}

### Cleaners ###################################################################

# Npm remove all global packages (except later npm installed via npm)
npmclear() {
  npm ls --location=global -p --depth=0 |
    awk -F/ '/node_modules/ && !/\/npm$/ {print $NF}' |
    xargs npm --location=global rm
}

# Gem remove all
gemclear() {
  gem uninstall -aIx
}

# Pip(x) remove all
pipclear() {
  command -v uv >/dev/null && uv tool uninstall --all
  command -v pipx >/dev/null && pipx uninstall-all
  pip list --format=freeze | grep -v "^-e" | grep -v "^pip==" |
    cut -d "@" -f1 | xargs --no-run-if-empty pip uninstall -y
}

# Remove all non-cask formulae
brewclear() {
  printf "Are you sure to remove all Homebrew formulae [y\N] > "
  read -r choice
  case "$choice" in
  [yY])
    brew list --formula | xargs brew uninstall --ignore-dependencies --force
    ;;
  *)
    printf "Aborted.\n"
    ;;
  esac
}

# Remove all VS Code extensions
codeclear() {
  printf "Are you sure to remove all VS Code extensions [y\N] > "
  read -r choice
  case "$choice" in
  [yY])
    code --list-extensions | while read -r extension; do
      code --force --uninstall-extension "$extension"
    done
    ;;
  *)
    printf "Aborted.\n"
    ;;
  esac
}

# Remove all Cursor extensions
cursorclear() {
  printf "Are you sure to remove all Cursor extensions [y\N] > "
  read -r choice
  case "$choice" in
  [yY])
    cursor --list-extensions | while read -r extension; do
      cursor --force --uninstall-extension "$extension"
    done
    ;;
  *)
    printf "Aborted.\n"
    ;;
  esac
}

# Remove all Antigravity extensions
agyclear() {
  printf "Are you sure to remove all Antigravity extensions [y\N] > "
  read -r choice
  case "$choice" in
  [yY])
    agy --list-extensions | while read -r extension; do
      agy --force --uninstall-extension "$extension"
    done
    ;;
  *)
    printf "Aborted.\n"
    ;;
  esac
}

### Nix ########################################################################

# Nix in containerd
nixd() {
  if [ -z "$1" ]; then
    local bin="bash"
  else
    local bin="$1"
    shift
  fi
  local image="nix"
  local name="$image-${PWD##*/}"

  if [ -n "$PORT" ]; then
    local port_args=""
    local first_port=""

    # Split PORT by comma and create publish args for each
    local remaining_ports="$PORT"
    while [ -n "$remaining_ports" ]; do
      if [ "$remaining_ports" != "${remaining_ports#*,}" ]; then
        # Contains comma, extract first port
        local port="${remaining_ports%%,*}"
        remaining_ports="${remaining_ports#*,}"
      else
        # No more commas, this is the last port
        local port="$remaining_ports"
        remaining_ports=""
      fi

      # Trim whitespace and skip empty ports
      port=$(echo "$port" | xargs)
      if [ -n "$port" ]; then
        port_args="$port_args --publish $port:$port"
        # Use first valid port as the main PORT env var for the container
        if [ -z "$first_port" ]; then
          first_port="$port"
        fi
      fi
    done

    # Pass only the first port as PORT env var to the container
    local env_args="--env PORT=$first_port"
  fi

  [ -r "$PWD/.env" ] && local env_file="--env-file $PWD/.env"

  podman start "$name" &>/dev/null ||
    (podman build --tag "$image" ~/configent/etc/nix &&
      eval podman run --init -t --detach \
        --name "$name" \
        "$port_args" \
        --volume "$PWD:$PWD" \
        --workdir "$PWD" \
        "$image")
  eval podman exec -it \
    "$env_file" \
    "$env_args" \
    --workdir "$PWD" \
    "$name" "$bin" "$*"
}

# Generic nix-shell builder and runner
n() {
  [ -z "$1" ] && echo "Usage: $0 nix-pkg1[/nix-pkgN] [ARGUMENTS]" && return
  local packages="${1//\// }"
  # shellcheck disable=SC1001   # escape forward slash on purpose
  case "$1" in shell*)
    shift
    local packages="${packages#* }"
    local command="bash -c '$*'"
    ;;
  *\/*)
    shift
    local bin="${packages%% *}"
    local command="$bin $*"
    ;;
  *)
    local command="$*"
    ;;
  esac
  # shellcheck disable=SC2086   # command has to be in quotes
  nixd nix-shell --quiet --packages "$packages" --command \"$command\"
}

# https://nixery.dev/
nixery() {
  [ -z "$1" ] && echo "Usage: $0 nix-pkg1[/nix-pkgN] [ARGUMENTS]" && return
  local packages="$1"
  shift
  local bin="${packages%%/*}"
  if [ "$bin" = "shell" ]; then
    local command="bash -c '$*'"
  else
    local command="$bin $*"
  fi
  if [ "$(uname -m)" = 'arm64' ] || [ "$(uname -m)" = 'aarch64' ]; then
    local image="nixery.dev/arm64/$packages"
  else
    local image="nixery.dev/$packages"
  fi
  eval nerdctl run --init -it --rm \
    --volume "$PWD:$PWD":rro,rprivate \
    --workdir "$PWD" \
    "$image" "$command"
}

### ad-hoc binaries via Nix

# file explorers
alias yazi='n yazi/ffmpegthumbnailer/unar/jq/poppler/fd/ripgrep/fzf/zoxide/vim'

# file conversion
alias pdftotext='n shell/poppler-utils pdftotext'

# ripgrep, but also search in pdfs, zip, tar.gz, etc. (see --rga-list-adapters)
alias rga='n shell/ffmpeg/pandoc/poppler/ripgrep/ripgrep-all rga'

# servers
alias miniserve='PORT=8000 n miniserve --hide-version-footer --port \$PORT $PWD'

# cloud
alias azcopy='n shell/azure-storage-azcopy azcopy'
alias termscp='n termscp/vim' # does not work natively on macOS

# appsec
alias grype='n grype'
alias syft='n syft'

# secrets
alias trufflehog='n trufflehog/git'

# sast
alias hadolint='n hadolint'
alias kubescape='n kubescape'
alias terrascan='n terrascan'

# database clients
alias mysql='n shell/mariadb mysql'
alias psql='n shell/postgresql psql'
alias sqlcmd='n sqlcmd'

# decoders
alias binsider='n binsider'
alias fq='n fq'
alias hexyl='n hexyl'
alias lemmeknow='n lemmeknow'

# development
alias bitwise='n bitwise'
alias difft='n shell/difftastic difft'
alias grex='n grex'
alias tokei='n tokei'
alias wrkflw='n wrkflw'

# load testing
alias k6='n k6'
alias oha='n oha'

# port scanners
alias naabu='n naabu'
alias rustscan='n rustscan'

# osint
alias maigret='n maigret'

# enumeration
alias amass='n amass'
alias feroxbuster='n feroxbuster'
alias gobuster='n gobuster'
alias katana='n katana'

# dns scanners
alias dnstwist='n dnstwist'
alias subfinder='n subfinder'

# web scanners
alias ffuf='n ffuf'
alias nikto='n nikto'
alias nuclei='n nuclei'
alias wapiti='n wapiti'

# xss scanners
alias dalfox='n dalfox'

# pentesting
alias msfconsole='n shell/metasploit msfconsole'
alias sqlmap='n sqlmap'

# password recovery
alias hashcat='n hashcat'
alias hydra='n shell/thc-hydra hydra'
